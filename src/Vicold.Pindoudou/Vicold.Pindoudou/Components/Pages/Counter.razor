@page "/counter"
@using System.Threading.Tasks
@using System.Collections.Generic
@using Vicold.Pindoudou.Entities
@using Vicold.Pindoudou.Utils
@using Vicold.Pindoudou.Services
@using Microsoft.JSInterop
@inject NavigationManager NavigationManager
@inject Microsoft.JSInterop.IJSRuntime JSRuntime
@inject IFileSaveService FileSaveService

<div class="app-container" @onkeydown="HandleKeyDown" tabindex="0">

    <!-- å³ä¾§æ§åˆ¶é¢æ¿ -->
    <aside class="control-sidebar @(IsSidebarCollapsed ? "collapsed" : "")">
        <div class="sidebar-header">
            <h3>å·¥å…·å°</h3>
        </div>
        <div class="control-panel">
            <div class="panel-info">
                <span class="pixel-size">å°ºå¯¸: @Width Ã— @Height</span>
            </div>
            <!-- å·¥å…·é€‰æ‹© -->
            <div class="panel-section">
                <h4>å·¥å…·</h4>
                <div class="tool-buttons">
                    <button class="tool-btn @(CurrentTool == EditTool.Brush ? "active" : "")" @onclick="() => SwitchTool(EditTool.Brush)">
                        <div class="tool-icon">ğŸ–Œï¸</div>
                        <div class="tool-name">ç”»ç¬”</div>
                    </button>
                    <button class="tool-btn @(CurrentTool == EditTool.Bucket ? "active" : "")" @onclick="() => SwitchTool(EditTool.Bucket)">
                        <div class="tool-icon">ğŸª£</div>
                        <div class="tool-name">æ²¹æ¼†æ¡¶</div>
                    </button>
                    <button class="tool-btn @(CurrentTool == EditTool.EyeDropper ? "active" : "")" @onclick="() => SwitchTool(EditTool.EyeDropper)">
                        <div class="tool-icon">ğŸ¨</div>
                        <div class="tool-name">å–è‰²å™¨</div>
                    </button>
                    <button class="tool-btn @(CurrentTool == EditTool.Eraser ? "active" : "")" @onclick="() => SwitchTool(EditTool.Eraser)">
                        <div class="tool-icon">ğŸ§½</div>
                        <div class="tool-name">æ©¡çš®æ“¦</div>
                    </button>
                    <button class="action-btn" @onclick="Undo" title="æ’¤é”€ (Ctrl+Z)">
                        <div class="action-icon">â†¶</div>
                        <div class="action-name">æ’¤é”€</div>
                    </button>
                    <button class="action-btn" @onclick="Redo" title="é‡åš (Ctrl+Y)">
                        <div class="action-icon">â†·</div>
                        <div class="action-name">é‡åš</div>
                    </button>
                </div>
            </div>

            <!-- é¢œè‰²é¢„è§ˆ -->
            <div class="panel-section">
                <h4>å½“å‰é¢œè‰²</h4>
                <div class="color-preview-container">
                    <div class="color-preview" style="background-color: @SelectedColor.ToString();">
                        <span style="color: @ColorUtil.GetContrastTextColor(SelectedColor); font-weight: bold;">
                            @SelectedColor.Code
                        </span>
                    </div>
                </div>
            </div>

            <!-- è°ƒè‰²æ¿ -->
            <div class="panel-section">
                <h4>è°ƒè‰²æ¿</h4>
                <div class="palette-display">
                    <div class="scrollable-palette">
                        @if (PaletteColors != null)
                        {
                            @foreach (var color in PaletteColors)
                            {
                                <div 
                                class="compact-color-item" 
                                @onclick="() => SelectColor(color.Value)"
                                title="@color.Key: @color.Value.ToString()"
                            >
                                <div 
                                    class="color-swatch" 
                                    style="background-color: @color.Value.ToString()"
                                >
                                    <div class="color-code" style="color: @ColorUtil.GetContrastTextColor(color.Value)">
                                        @color.Key
                                    </div>
                                </div>
                            </div>
                            }
                        }
                    </div>
                </div>
            </div>

            <!-- é€‰é¡¹è®¾ç½® -->
            <div class="panel-section">
                <h4>é€‰é¡¹</h4>
                <div class="checkbox-group">
                    <label class="form-check">
                        <input type="checkbox" class="form-check-input" @bind="ShowCodes">
                        <span class="form-check-label">æ˜¾ç¤ºé¢œè‰²ä»£ç </span>
                    </label>
                    <label class="form-check">
                        <input type="checkbox" class="form-check-input" @bind="HideTransparentCodes">
                        <span class="form-check-label">éšè—é€æ˜ä»£ç </span>
                    </label>
                </div>
            </div>
            
            <!-- åƒç´ ä½¿ç”¨ç»Ÿè®¡ -->
            <div class="panel-section">
                <h4>å·²ä½¿ç”¨è‰²å—</h4>
                <div class="palette-display">
                    @if (PixelUsageStats != null && PixelUsageStats.Count > 0)
                    {
                        <div class="scrollable-palette">
                            @foreach (var stat in PixelUsageStats)
                            {
                                var color = stat.Key;
                                var count = stat.Value;
                                var textColor = ColorUtil.GetContrastTextColor(color);
                                <div class="compact-color-item"
                                @onclick="() => SelectColor(color)"
                                title="@color.Code: @color.ToString()" >
                                    <div class="color-swatch" style="background-color: @color.ToString()">
                                            <div class="color-code" style="color: @textColor">
                                        @color.Code
                                    </div>
                                    </div>
                                    <div class="stat-count">@count</div>
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        <div class="empty-stats">
                            æš‚æ— ç»Ÿè®¡æ•°æ®
                        </div>
                    }
                </div>
            </div>
            <!-- ä¸»è¦æŒ‰é’® -->
            <div class="panel-section">
                <div class="main-buttons">
                    <button class="main-btn export" @onclick="ExportPixelArt">
                        <div class="btn-icon">ğŸ“¤</div>
                        <div class="btn-text">å¯¼å‡ºå›¾ç‰‡</div>
                    </button>
                    <button class="main-btn save" @onclick="SaveResource">
                        <div class="btn-icon">ğŸ’¾</div>
                        <div class="btn-text">ä¿å­˜èµ„æº</div>
                    </button>
                    <button class="main-btn open" @onclick="OpenResource">
                        <div class="btn-icon">ğŸ“</div>
                        <div class="btn-text">å¯¼å…¥èµ„æº</div>
                    </button>
                    <button class="main-btn back" @onclick="GoBack">
                        <div class="btn-icon">â¬…ï¸</div>
                        <div class="btn-text">è¿”å›ä¸»é¡µ</div>
                    </button>
                </div>
            </div>

            <!-- æ¶ˆæ¯æç¤º -->
            @if (!string.IsNullOrEmpty(Message))
            {
                <div class="message-alert">
                    @Message
                </div>
            }
        </div>
    </aside>

    <!-- æµ®åŠ¨æ§åˆ¶æŒ‰é’® -->
    <button class="floating-expand-btn" @onclick="ToggleSidebar" title="@(IsSidebarCollapsed ? "å±•å¼€æ§åˆ¶é¢æ¿" : "æ”¶èµ·æ§åˆ¶é¢æ¿")">
        @(IsSidebarCollapsed ? "ğŸ¨" : "â–¶")
    </button>

    <!-- åƒç´ å›¾ç¼–è¾‘åŒºåŸŸ - å æ®æ‰€æœ‰ç©ºé—´ -->
    <section class="edit-area @(IsSidebarCollapsed ? "collapsed" : "")">
        <div class="edit-panel">
            <div class="panel-body">
                <div class="edit-container">
                    @if (PixelData != null && PixelData.Length > 0)
                    {
                        <div class="zoomable-container" id="zoomableContainer" @onmouseleave="StopDrawing">
                            <div class="zoomable-content" id="zoomableContent" style="transform-origin: 0 0;">
                                <div class="pixel-art">
                                    @for (int y = 0; y < Height; y++)
                                    {
                                        <div class="pixel-row">
                                            @for (int x = 0; x < Width; x++)
                                            {
                                                var currentX = x;
                                                var currentY = y;
                                                var index = y * Width + x;
                                                if (index < PixelData.Length)
                                                {
                                                    <div 
                                                        class="pixel" 
                                                        style="background-color: @PixelData[index].ToString()"
                                                        @onmousedown="(e) => HandleMouseDown(currentX, currentY, e)"
                                                        @onmousedown:preventDefault="true"
                                                        @onmouseup="StopDrawing"
                                                        @onmouseover="() => DrawIfMouseDown(currentX, currentY)"
                                                        title="@PixelData[index].Code"
                                                    >
                                                        @if (ShowCodes && PaletteColors != null)
                                                        {
                                                            var code = GetCodeByColorFast(PixelData[index], HideTransparentCodes);
                                                            if (!string.IsNullOrEmpty(code))
                                                            {
                                                                var textColor = ColorUtil.GetContrastTextColor(PixelData[index]);
                                                                <div class="color-number-in-pixel" style="color: @textColor">
                                                                    @(code)
                                                                </div>
                                                            }
                                                        }
                                                    </div>
                                                }
                                            }
                                        </div>
                                    }
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="empty-state">
                            <div class="empty-icon">ğŸ¨</div>
                            <div class="empty-text">æ²¡æœ‰å¯ç¼–è¾‘çš„åƒç´ å›¾</div>
                            <div class="empty-subtext">è¯·å…ˆåœ¨ä¸»é¡µç”Ÿæˆåƒç´ å›¾æˆ–ç‚¹å‡»å¯¼å…¥ç´ æ</div>
                        </div>
                    }
                </div>
            </div>
        </div>
    </section>
</div>

<style>
    /* åº”ç”¨å®¹å™¨æ ·å¼ - é€‚åº”MainLayoutå¸ƒå±€ */
    .app-container {
        width: 100%;
        height: 100%;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #333;
        display: flex;
        overflow: hidden;
        position: relative;
        max-width: 100%;
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }
    
    .app-container > aside {
        position: fixed;
        right: 0;
        top: 0px;
        bottom: 0;
        z-index: 80;
        transition: transform 0.3s ease;
    }
    
    .app-container > section {
        flex: 1;
        transition: margin-left 0.3s ease;
        overflow: hidden;
        max-width: 100vw; /* é™åˆ¶æœ€å¤§å®½åº¦ï¼Œå‡å»å³ä¾§æ§åˆ¶é¢æ¿çš„å®½åº¦ */
    }
    
    /* å¤´éƒ¨æ ·å¼ */
    .app-header {
        background-color: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 0.8rem 0;
        position: sticky;
        top: 0;
        z-index: 100;
    }
    
    .header-content {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 2rem;
        text-align: center;
    }
    
    .app-header h1 {
        color: #667eea;
        font-size: 1.5rem;
        margin-bottom: 0;
        font-weight: 700;
    }
    
    .app-subtitle {
        color: #666;
        font-size: 0.9rem;
        font-weight: 400;
    }
    
    /* å³ä¾§æ§åˆ¶é¢æ¿ */
    .control-sidebar {
        width: 320px;
        background-color: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px 0 0 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        padding: 0.5rem;
        height: 100vh;
        overflow-y: auto;
        transform: translateX(0);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        z-index: 80;
    }
    
    .control-sidebar:hover {
        box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
    }
    
    .control-sidebar.collapsed {
        transform: translateX(100%);
    }
    
    .sidebar-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
    }
    
    .collapse-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        font-size: 1.2rem;
        cursor: pointer;
        color: white;
        padding: 0.75rem;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    
    .collapse-btn:hover {
        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        transform: scale(1.1) rotate(90deg);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }
    
    /* æµ®åŠ¨å±•å¼€æŒ‰é’® */
    .floating-expand-btn {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        z-index: 100;
    }
    
    /* å›ºå®šæ”¶èµ·æŒ‰é’® */
    .fixed-collapse-btn {
        position: fixed;
        right: 20px;
        top: 20px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        z-index: 100;
    }
    
    .fixed-collapse-btn:hover {
        transform: scale(1.1) rotate(90deg);
        box-shadow: 0 6px 25px rgba(102, 126, 234, 0.5);
    }
    
    .floating-expand-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 25px rgba(102, 126, 234, 0.5);
    }
    
    .control-panel {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }
    
    .panel-section {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .panel-section h3 {
        color: #333;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #f0f0f0;
    }
    
    .panel-section h4 {
        color: #333;
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #f0f0f0;
    }
    
    /* è°ƒè‰²æ¿æ ·å¼ */
    .palette-display {
        border: 1px solid #e9ecef;
        background-color: #f8f9fa;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .scrollable-palette {
        padding: 1rem;
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 8px;
        max-height: 400px;
        overflow-y: auto;
    }
    
    /* æ»šåŠ¨æ¡æ ·å¼ */
    .scrollable-palette::-webkit-scrollbar {
        width: 6px;
    }
    
    .scrollable-palette::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
    }
    
    .scrollable-palette::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 3px;
    }
    
    .scrollable-palette::-webkit-scrollbar-thumb:hover {
        background: #a8a8a8;
    }
    
    .compact-color-item {
        cursor: pointer;
        transition: all 0.2s ease;
        border-radius: 4px;
        overflow: hidden;
    }
    
    .compact-color-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .color-swatch {
        width: 100%;
        height: 30px;
        border: 2px solid #e0e0e0;
        border-radius: 4px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }
    
    .compact-color-item:hover .color-swatch {
        border: 2px solid #667eea;
        transform: scale(1.05);
    }

    .color-code {
        font-size: 11px;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    /* å·¥å…·éƒ¨åˆ†æ ·å¼ */
    .tool-section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    
    .tool-label {
        color: #666;
        font-size: 0.9rem;
        font-weight: 500;
    }
    
    .color-preview-container {
        display: flex;
        align-items: center;
    }
    
    .color-preview {
        width: 100%;
        height: 60px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #fff;
    }
    
    .color-preview:hover {
        border-color: #667eea;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        transform: scale(1.02);
    }
    
    /* å·¥å…·æŒ‰é’®æ ·å¼ */
    .tool-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
    }
    
    .tool-btn {
        flex: 1 1 calc(50% - 0.375rem); /* æ¯è¡Œæ˜¾ç¤ºä¸¤ä¸ªæŒ‰é’®ï¼Œå‡å»ä¸€åŠçš„é—´è· */
        min-width: 80px; /* è®¾ç½®æœ€å°å®½åº¦ï¼Œç¡®ä¿æŒ‰é’®ä¸ä¼šå¤ªå° */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        background-color: #f8f9fa;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.9rem;
        font-weight: 500;
        color: #666;
    }
    
    .tool-btn:hover {
        border-color: #667eea;
        background-color: #f0f4ff;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .tool-btn.active {
        border-color: #667eea;
        background-color: #667eea;
        color: white;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .tool-icon {
        font-size: 1.5rem;
    }
    
    .tool-name {
        font-size: 0.85rem;
    }
    
    /* æ“ä½œæŒ‰é’®æ ·å¼ */
    .action-buttons {
        display: flex;
        gap: 0.75rem;
    }
    
    .action-btn {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.75rem;
        background-color: #f8f9fa;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.9rem;
        font-weight: 500;
        color: #666;
    }
    
    .action-btn:hover {
        border-color: #667eea;
        background-color: #f0f4ff;
        transform: translateY(-2px);
    }
    
    .action-icon {
        font-size: 1rem;
    }
    
    .action-name {
        font-size: 0.85rem;
    }
    
    /* å¤é€‰æ¡†ç»„æ ·å¼ */
    .checkbox-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    
    .form-check {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        border-radius: 6px;
        padding: 0px 50px;
        transition: background-color 0.2s ease;
        position: relative;
    }
    
    .form-check:hover {
        background-color: #f0f4ff;
    }
    
    .form-check-input {
        width: 16px;
        height: 16px;
        accent-color: #667eea;
        z-index: 100;
        position: relative;
        margin: 0;
        flex-shrink: 0;
    }
    
    .form-check-label {
        font-size: 0.9rem;
        color: #666;
        cursor: pointer;
        flex: 1;
    }
    
    /* ä¸»æŒ‰é’®æ ·å¼ */
    .main-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    
    .main-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 1rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.95rem;
        font-weight: 600;
        color: white;
    }
    
    .main-btn.export {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }
    
    .main-btn.save {
        background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }
    
    .main-btn.open {
        background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    }
    
    .main-btn.back {
        background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        color: #666;
    }
    
    .main-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .btn-icon {
        font-size: 1.1rem;
    }
    
    .btn-text {
        font-size: 0.95rem;
    }
    
    /* æ¶ˆæ¯æç¤ºæ ·å¼ */
    .message-alert {
        background-color: #f0f4ff;
        border-left: 4px solid #667eea;
        padding: 1rem;
        border-radius: 0 8px 8px 0;
        font-size: 0.9rem;
        color: #333;
        font-weight: 500;
        animation: slideIn 0.3s ease;
    }
    
    @@keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    /* ç¼–è¾‘åŒºåŸŸ */
    .edit-area {
        flex: 1;
        background-color: #f8f9ff;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
    }
    
    .edit-panel {
        display: flex;
        flex-direction: column;
        flex: 1;
        padding: 20px;
        box-sizing: border-box;
    }
    
    .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #f0f0f0;
        flex-shrink: 0;
    }
    
    .panel-header h3 {
        color: #333;
        font-size: 1.2rem;
        font-weight: 600;
    }
    
    .panel-info {
        display: flex;
        align-items: center;
        gap: 1rem;
        font-size: 0.9rem;
        color: #666;
    }
    
    .pixel-size {
        background-color: #f0f4ff;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-weight: 500;
        color: #667eea;
    }
    
    .panel-body {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
    
    /* ç¼–è¾‘å®¹å™¨æ ·å¼ */
    .edit-container {
        width: 100%;
        height: 100%;
        border: 2px dashed #dee2e6;
        border-radius: 8px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ffffff;
        transition: all 0.3s ease;
        box-sizing: border-box;
        overflow: hidden;
    }
    
    .edit-container:hover {
        border-color: #667eea;
        background-color: #f8f9ff;
    }
    
    /* ç¼©æ”¾å®¹å™¨æ ·å¼ */
    .zoomable-container {
        width: 100%;
        height: calc(100vh - 46px);
        overflow: hidden;
        position: relative;
        background-color: #fff;
        border: none;
        border-radius: 0;
        box-shadow: none;
        cursor: grab;
        max-width: 100%;
        box-sizing: border-box;
        max-height: 100%;
    }
    
    .zoomable-container:active {
        cursor: grabbing;
    }
    
    .zoomable-content {
        position: relative;
        transform-origin: 0 0;
        transition: transform 0.1s ease;
        margin: 0 auto;
        display: inline-block;
    }
    
    /* åƒç´ è‰ºæœ¯æ ·å¼ */
    .pixel-art {
        margin: 0;
        display: inline-block;
    }
    
    .pixel-row {
        display: flex;
    }
    
    .pixel {
        width: 24px;
        height: 24px;
        border: 1px solid #e0e0e0;
        cursor: pointer;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: transform 0.2s ease, border-color 0.2s ease;
    }
    
    .pixel:hover {
        border: 1px solid #667eea;
        transform: scale(1.1);
        z-index: 10;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    
    .color-number-in-pixel {
        font-size: 9px;
        font-weight: bold;
        text-align: center;
        width: 100%;
        line-height: 1;
        margin: 0;
        padding: 0;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    /* ç©ºçŠ¶æ€æ ·å¼ */
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #999;
        text-align: center;
        gap: 1.5rem;
    }

    .empty-icon {
        font-size: 6rem;
        opacity: 0.6;
        animation: bounce 2s infinite;
    }

    @@keyframes bounce {
        0%, 20%, 50%, 80%, 100% {
            transform: translateY(0);
        }
        40% {
            transform: translateY(-20px);
        }
        60% {
            transform: translateY(-10px);
        }
    }

    .empty-text {
        font-size: 1.3rem;
        font-weight: 600;
        color: #666;
    }

    .empty-subtext {
        font-size: 1rem;
        color: #999;
        max-width: 300px;
    }

    /* å“åº”å¼è®¾è®¡ */
    @@media (max-width: 641px) {
        .edit-area {
        }

        .control-sidebar {
            top: 50px !important;
            height: calc(100vh - 50px);
            z-index: 999;
        }
    }

    /* åƒç´ ç»Ÿè®¡æ ·å¼ */
    .pixel-stats {
        border: 1px solid #e9ecef;
        padding: 1rem;
        background-color: #f8f9fa;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        background-color: #ffffff;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
    }
    
    .stat-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
    }
    
    .stat-color {
        width: 40px;
        height: 40px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #e0e0e0;
        flex-shrink: 0;
    }
    
    .stat-code {
        font-size: 12px;
        font-weight: bold;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    .stat-count {
        font-size: 0.8rem;
        font-weight: 500;
        color: #333;
        text-align: center;
    }
    
    .empty-stats {
        text-align: center;
        color: #999;
        font-size: 0.9rem;
        padding: 1rem;
    }
    
    /* å“åº”å¼è®¾è®¡ */
    @@media (max-width: 768px) {
        .control-sidebar {
            width: 100vw; /* ç§»åŠ¨è®¾å¤‡ä¸Šä½¿ç”¨å…¨å±å®½åº¦ */
            border-radius: 0;
        }
        
        .control-sidebar.collapsed {
            transform: translateX(100%); /* æ”¶èµ·æ—¶å®Œå…¨éšè— */
        }
        
        .edit-area {
            margin-right: 0;
            padding-left: 0; /* å°å±å¹•ä¸Šä¸éœ€è¦ä¸ºå¯¼èˆªæ ç•™å‡ºç©ºé—´ */
        }
        
        .edit-area.collapsed {
            margin-right: 0;
        }
        
        .app-header {
            padding: 0.6rem 0;
        }
        
        .app-header h1 {
            font-size: 1.3rem;
        }
        
        .control-sidebar {
            z-index: 999;
        }
        
        .edit-area {
            height: calc(100vh - 50px);
        }
        
        .scrollable-palette {
            grid-template-columns: repeat(6, 1fr);
        }
        
        .tool-buttons {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .tool-btn {
            flex: 1 1 calc(25% - 0.375rem); /* æ¯è¡Œæ˜¾ç¤ºå››ä¸ªæŒ‰é’® */
            min-width: 60px;
            padding: 0.5rem;
            font-size: 0.7rem;
        }
        
        .tool-icon {
            font-size: 1.1rem;
        }
        
        .tool-name {
            font-size: 0.7rem;
        }
        
        .action-buttons {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .action-btn {
            flex: 1 1 calc(50% - 0.25rem); /* æ¯è¡Œæ˜¾ç¤ºä¸¤ä¸ªæŒ‰é’® */
            min-width: 80px;
            padding: 0.5rem;
            font-size: 0.75rem;
        }
        
        .action-icon {
            font-size: 0.8rem;
        }
        
        .action-name {
            font-size: 0.7rem;
        }
        
        .pixel {
            width: 18px;
            height: 18px;
        }
        
        .edit-container {
            padding: 0.5rem;
        }
        
        /* è°ƒæ•´æµ®åŠ¨æŒ‰é’®åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šçš„å¤§å°å’Œä½ç½® */
        .floating-expand-btn {
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            right: 15px;
            bottom: 15px;
            z-index: 1000;
        }
        
        /* è°ƒæ•´ä¸»æŒ‰é’®åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šçš„æ ·å¼ */
        .main-buttons {
            gap: 0.5rem;
        }
        
        .main-btn {
            padding: 0.75rem;
            font-size: 0.8rem;
            gap: 0.5rem;
        }
        
        .btn-icon {
            font-size: 0.9rem;
        }
        
        .btn-text {
            font-size: 0.8rem;
        }
        
        .stat-item {
            gap: 0.4rem;
            padding: 0.4rem;
        }
        
        .stat-color {
            width: 35px;
            height: 35px;
        }
        
        .stat-code {
            font-size: 10px;
        }
        
        .stat-count {
            font-size: 0.7rem;
        }
    }
</style>

@code {
    private enum EditTool
    {
        Brush,
        Bucket,
        Eraser,
        EyeDropper
    }
    
    private Color[]? PixelData { get; set; }
    private int Width { get; set; }
    private int Height { get; set; }
    private string Palette { get; set; } = "Mard";
    private Dictionary<string, Color> PaletteColors { get; set; } = new Dictionary<string, Color>();

    private Color SelectedColor { get; set; } = new Color(255, 255, 255);
    private bool ShowCodes { get; set; } = true;
    private bool HideTransparentCodes { get; set; } = false;
    private string Message { get; set; } = string.Empty;
    private bool IsDrawing { get; set; } = false;
    private EditTool CurrentTool { get; set; } = EditTool.Brush;
    private EditTool PreviousTool { get; set; } = EditTool.Brush;
    private Stack<Color[]> UndoStack { get; set; } = new Stack<Color[]>();
    private Stack<Color[]> RedoStack { get; set; } = new Stack<Color[]>();
    private bool IsSidebarCollapsed { get; set; } = false;
    private System.Diagnostics.Stopwatch? EditStopwatch { get; set; } // ç”¨äºæ€§èƒ½æµ‹é‡
    private System.Threading.CancellationTokenSource? SaveDebounceToken { get; set; } // é˜²æŠ–ä»¤ç‰Œ
    private const int SaveDebounceDelay = 1000; // é˜²æŠ–å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    private Dictionary<Color, int> PixelUsageStats { get; set; } = new Dictionary<Color, int>(); // åƒç´ ä½¿ç”¨ç»Ÿè®¡
    private DotNetObjectReference<Counter>? _dotNetReference; // ç”¨äºJavaScriptè°ƒç”¨C#æ–¹æ³•

    protected override async Task OnInitializedAsync()
    {
        // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å¯¼èˆªæ•°æ®ï¼ˆæ–°ç”Ÿæˆçš„åƒç´ å›¾ï¼‰
        var hasNavigationData = await LoadFromNavigationData();
        
        // å¦‚æœæ²¡æœ‰å¯¼èˆªæ•°æ®ï¼Œå†æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„çŠ¶æ€
        if (!hasNavigationData)
        {
            var savedStateJson = await JSRuntime.InvokeAsync<string>("sessionStorage.getItem", "counterState");
            
            if (!string.IsNullOrEmpty(savedStateJson))
            {
                try
                {
                    // ä½¿ç”¨å…·ä½“çš„ç±»å‹è€Œä¸æ˜¯dynamic
                    var options = new System.Text.Json.JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true
                    };
                    
                    var navigationData = System.Text.Json.JsonSerializer.Deserialize<NavigationData>(savedStateJson, options);
                    
                    if (navigationData != null)
                    {
                        // é‡ç½®çŠ¶æ€
                        UndoStack.Clear();
                        RedoStack.Clear();
                        
                        // è§£æå‚æ•°
                        Width = navigationData.Width;
                        Height = navigationData.Height;
                        Palette = navigationData.Palette;
                        
                        // è§£æè°ƒè‰²æ¿é¢œè‰²
                        var paletteColorsString = navigationData.CurrentPalette;
                        PaletteColors.Clear();
                        foreach (var color in paletteColorsString)
                        {
                            var colorObj = Color.FromHex(color.Value, color.Key);
                            PaletteColors[color.Key] = colorObj; // codeä¸ºkeyï¼Œcolorä¸ºvalue
                        }
                        
                        // è§£æåƒç´ æ•°æ®
                        var pixelDataString = navigationData.PixelData;
                        if (!string.IsNullOrEmpty(pixelDataString))
                        {
                            var colorStrings = pixelDataString.Split(',');
                            PixelData = new Color[colorStrings.Length];
                            for (int i = 0; i < colorStrings.Length; i++)
                            {
                                var color = Color.FromHex(colorStrings[i]);
                                // Find the corresponding code in PaletteColors
                                foreach (var paletteColor in PaletteColors)
                                {
                                    if (paletteColor.Value.Equals(color))
                                    {
                                        color.Code = paletteColor.Key;
                                        break;
                                    }
                                }
                                PixelData[i] = color;
                            }
                        }
                        else
                        {
                            PixelData = Array.Empty<Color>();
                        }
                        
                        // è®¾ç½®é»˜è®¤é€‰æ‹©çš„é¢œè‰²
                        if (PaletteColors.Count > 0)
                        {
                            SelectedColor = PaletteColors.First().Value;
                        }
                    }
                    
                    // ä¿ç•™ä¿å­˜çš„çŠ¶æ€ï¼Œä»¥ä¾¿åç»­å¯¼èˆªå›æ¥æ—¶ä»èƒ½ä½¿ç”¨
                    // æ³¨æ„ï¼šä¸è¦æ¸…é™¤ sessionStorage ä¸­çš„æ•°æ®
                }
                catch (Exception ex)
                {
                    // é”™è¯¯å¤„ç†
                    Console.WriteLine($"Error parsing saved state: {ex.Message}");
                }
            }
        }
        
        // è®¡ç®—åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
        CalculatePixelUsageStats();
    }
    
    private async Task<bool> LoadFromNavigationData()
    {
        // ä» sessionStorage ä¸­è·å–å¯¼èˆªæ•°æ®
        var jsonData = await JSRuntime.InvokeAsync<string>("sessionStorage.getItem", "navigationData");
        
        if (!string.IsNullOrEmpty(jsonData))
        {
            try
            {
                // æ¸…é™¤ sessionStorage ä¸­çš„å¯¼èˆªæ•°æ®ï¼ˆå°½æ—©æ¸…é™¤ï¼Œé¿å…é‡å¤åŠ è½½ï¼‰
                await JSRuntime.InvokeVoidAsync("sessionStorage.removeItem", "navigationData");
                
                // ä½¿ç”¨å…·ä½“çš„ç±»å‹è€Œä¸æ˜¯dynamic
                var options = new System.Text.Json.JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };
                
                var navigationData = System.Text.Json.JsonSerializer.Deserialize<NavigationData>(jsonData, options);
                
                if (navigationData != null)
                {
                    // é‡ç½®çŠ¶æ€
                    UndoStack.Clear();
                    RedoStack.Clear();
                    
                    // è§£æå‚æ•°
                    Width = navigationData.Width;
                    Height = navigationData.Height;
                    Palette = navigationData.Palette;
                    
                    // è§£æè°ƒè‰²æ¿é¢œè‰²
                    var paletteColorsString = navigationData.CurrentPalette;
                    PaletteColors.Clear();
                    foreach (var color in paletteColorsString)
                    {
                        var colorObj = Color.FromHex(color.Value, color.Key);
                        PaletteColors[color.Key] = colorObj; // codeä¸ºkeyï¼Œcolorä¸ºvalue
                    }
                    
                    // è§£æåƒç´ æ•°æ®
                    var pixelDataString = navigationData.PixelData;
                    if (!string.IsNullOrEmpty(pixelDataString))
                    {
                        var colorStrings = pixelDataString.Split(',');
                        PixelData = new Color[colorStrings.Length];
                        for (int i = 0; i < colorStrings.Length; i++)
                        {
                            var color = Color.FromHex(colorStrings[i]);
                            // Find the corresponding code in PaletteColors
                            foreach (var paletteColor in PaletteColors)
                            {
                                if (paletteColor.Value.Equals(color))
                                {
                                    color.Code = paletteColor.Key;
                                    break;
                                }
                            }
                            PixelData[i] = color;
                        }
                    }
                    else
                    {
                        PixelData = Array.Empty<Color>();
                    }
                    
                    // è®¾ç½®é»˜è®¤é€‰æ‹©çš„é¢œè‰²
                    if (PaletteColors.Count > 0)
                    {
                        SelectedColor = PaletteColors.First().Value;
                    }
                    
                    // ä¿å­˜å½“å‰çŠ¶æ€ï¼ˆä½¿ç”¨éé˜²æŠ–ç‰ˆæœ¬ï¼Œç¡®ä¿ç«‹å³ä¿å­˜ï¼‰
                    await SaveCurrentStateImmediately();
                    
                    // è®¡ç®—åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
                    CalculatePixelUsageStats();
                    
                    return true; // æˆåŠŸåŠ è½½å¯¼èˆªæ•°æ®
                }
            }
            catch (Exception ex)
            {
                // é”™è¯¯å¤„ç†
                Console.WriteLine($"Error parsing navigation data: {ex.Message}");
            }
        }
        
        return false; // æ²¡æœ‰å¯¼èˆªæ•°æ®æˆ–åŠ è½½å¤±è´¥
    }
    
    private async Task SaveCurrentStateImmediately()
    {
        // ç«‹å³ä¿å­˜çŠ¶æ€ï¼Œä¸ä½¿ç”¨é˜²æŠ–
        if (PixelData != null && PixelData.Length > 0)
        {
            // å°†Coloræ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ•°ç»„
            var colorStrings = PixelData.Select(c => c.ToString()).ToArray();
            var pixelDataString = string.Join(",", colorStrings);
            
            // å°†PaletteColorsè½¬æ¢ä¸ºDictionary<string, string>
            var paletteColorsStrings = new Dictionary<string, string>();
            foreach (var color in PaletteColors)
            {
                paletteColorsStrings[color.Key] = color.Value.ToString();
            }
            
            var navigationData = new NavigationData
            {
                Width = Width,
                Height = Height,
                Palette = Palette,
                PixelData = pixelDataString,
                CurrentPalette = paletteColorsStrings
            };
            
            var jsonData = System.Text.Json.JsonSerializer.Serialize(navigationData);
            await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "counterState", jsonData);
        }
    }
    
    private async Task EditPixel(int x, int y)
    {
        Color targetColor = SelectedColor;
        if (CurrentTool == EditTool.Eraser)
        {
            targetColor = new Color(255, 255, 255, 0);
        }
        
        Message = $"ç¼–è¾‘åƒç´ : x={x}, y={y}, é¢œè‰²={targetColor}";
        Console.WriteLine($"EditPixel called with x={x}, y={y}, TargetColor={targetColor}, Tool={CurrentTool}");
        if (PixelData != null)
        {
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°æ’¤é”€æ ˆ
            var currentState = new Color[PixelData.Length];
            Array.Copy(PixelData, currentState, PixelData.Length);
            UndoStack.Push(currentState);
            
            // æ¸…ç©ºé‡åšæ ˆ
            RedoStack.Clear();
            
            Console.WriteLine($"PixelData length: {PixelData.Length}");
            Color[] newPixelData;
            
            if (CurrentTool == EditTool.Brush || CurrentTool == EditTool.Eraser)
            {
                // ç”»ç¬”æˆ–æ©¡çš®æ“¦å·¥å…·ï¼šç¼–è¾‘å•ä¸ªåƒç´ 
                // æ‰‹åŠ¨å®ç°ç¼–è¾‘å•ä¸ªåƒç´ çš„é€»è¾‘ï¼Œå› ä¸ºPixelArtUtil.EditPixelå¯èƒ½ä¸æ”¯æŒColorç±»å‹
                newPixelData = new Color[PixelData.Length];
                Array.Copy(PixelData, newPixelData, PixelData.Length);
                int index = y * Width + x;
                if (index < newPixelData.Length)
                {
                    newPixelData[index] = targetColor;
                }
            }
            else
            {
                // æ²¹æ¼†æ¡¶å·¥å…·ï¼šæ´ªæ°´å¡«å……
                newPixelData = FloodFill(x, y, targetColor, PixelData);
            }
            
            Console.WriteLine($"New PixelData length: {newPixelData.Length}");
            PixelData = newPixelData;
            Console.WriteLine($"PixelData updated successfully");
            Message += " - æˆåŠŸ";
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            await SaveCurrentState();
            
            // æ›´æ–°åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
            CalculatePixelUsageStats();
        }
        else
        {
            Console.WriteLine("PixelData is null");
            Message += " - å¤±è´¥: PixelDataä¸ºnull";
        }
    }
    
    private Color[] FloodFill(int startX, int startY, Color newColor, Color[] pixelData)
    {
        // åˆ›å»ºåƒç´ æ•°æ®çš„å‰¯æœ¬
        var result = new Color[pixelData.Length];
        Array.Copy(pixelData, result, pixelData.Length);
        
        // è·å–èµ·å§‹åƒç´ çš„é¢œè‰²
        int startIndex = startY * Width + startX;
        Color targetColor = pixelData[startIndex];
        
        // å¦‚æœç›®æ ‡é¢œè‰²ä¸æ–°é¢œè‰²ç›¸åŒï¼Œç›´æ¥è¿”å›
        if (targetColor.Equals(newColor))
        {
            return result;
        }
        
        // ä½¿ç”¨ç®€å•çš„4æ–¹å‘æ´ªæ°´å¡«å……ç®—æ³•
        var queue = new Queue<(int, int)>();
        queue.Enqueue((startX, startY));
        
        // å®šä¹‰å››ä¸ªæ–¹å‘ï¼šä¸Šã€å³ã€ä¸‹ã€å·¦
        var directions = new (int, int)[] { (-1, 0), (0, 1), (1, 0), (0, -1) };
        
        while (queue.Count > 0)
        {
            var (x, y) = queue.Dequeue();
            int index = y * Width + x;
            
            // æ£€æŸ¥å½“å‰åƒç´ æ˜¯å¦æ˜¯ç›®æ ‡é¢œè‰²
            if (result[index].Equals(targetColor))
            {
                // è®¾ç½®æ–°é¢œè‰²
                result[index] = newColor;
                
                // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„ç›¸é‚»åƒç´ 
                foreach (var (dx, dy) in directions)
                {
                    int nx = x + dx;
                    int ny = y + dy;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹ç•Œå†…
                    if (nx >= 0 && nx < Width && ny >= 0 && ny < Height)
                    {
                        int nIndex = ny * Width + nx;
                        // æ£€æŸ¥ç›¸é‚»åƒç´ æ˜¯å¦æ˜¯ç›®æ ‡é¢œè‰²
                        if (result[nIndex].Equals(targetColor))
                        {
                            queue.Enqueue((nx, ny));
                        }
                    }
                }
            }
        }
        
        return result;
    }
    
    private void SelectColor(Color color)
    {
        Message = $"é€‰æ‹©é¢œè‰²: {color}";
        Console.WriteLine($"SelectColor called with color={color}");
        SelectedColor = color;
        Console.WriteLine($"SelectedColor updated to: {SelectedColor}");
    }
    
    private bool IsBatchEditing { get; set; } = false;
    private DateTime LastEditTime { get; set; } = DateTime.MinValue;
    private const int EditThrottleDelay = 50; // èŠ‚æµå»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    
    private async Task HandleMouseDown(int x, int y, MouseEventArgs e)
    {
        // å·¦é”®å¼€å§‹æ‰¹é‡ä¿®æ”¹
        if (e.Button == 0)
        {
            if (CurrentTool == EditTool.EyeDropper)
            {
                // å–è‰²å™¨å·¥å…·ï¼šè·å–ç‚¹å‡»ä½ç½®çš„é¢œè‰²
                if (PixelData != null)
                {
                    int index = y * Width + x;
                    if (index < PixelData.Length)
                    {
                        var color = PixelData[index];
                        SelectColor(color);
                        Message = $"å–è‰²æˆåŠŸ: {color}";
                        Console.WriteLine($"EyeDropper used at x={x}, y={y}, Color={color}");
                        
                        // å–è‰²åè‡ªåŠ¨è·³è½¬å›ä¸Šä¸€ä¸ªå·¥å…·
                        // å¦‚æœä¸Šä¸€ä¸ªå·¥å…·ä¸æ˜¯ç”»ç¬”æˆ–æ²¹æ¼†æ¡¶ï¼Œåˆ™é»˜è®¤è·³è½¬åˆ°ç”»ç¬”å·¥å…·
                        if (PreviousTool == EditTool.Brush || PreviousTool == EditTool.Bucket)
                        {
                            CurrentTool = PreviousTool;
                        }
                        else
                        {
                            CurrentTool = EditTool.Brush;
                        }
                    }
                }
            }
            else
            {
                // ä¿å­˜å½“å‰å·¥å…·ä½œä¸ºä¸Šä¸€ä¸ªå·¥å…·
                PreviousTool = CurrentTool;
                IsBatchEditing = true;
                await EditPixel(x, y);
                LastEditTime = DateTime.Now;
            }
        }
        // å³é”®ä¸åšä»»ä½•å¤„ç†ï¼Œè®©å®ƒè§¦å‘zoomableContainerçš„æ‹–åŠ¨åŠŸèƒ½
    }
    
    private void StopDrawing()
    {
        IsBatchEditing = false;
    }
    
    private async Task DrawIfMouseDown(int x, int y)
    {
        if (IsBatchEditing)
        {
            // èŠ‚æµï¼šé™åˆ¶ç¼–è¾‘æ“ä½œçš„é¢‘ç‡
            var now = DateTime.Now;
            if ((now - LastEditTime).TotalMilliseconds >= EditThrottleDelay)
            {
                await EditPixel(x, y);
                LastEditTime = now;
            }
        }
    }
    
    private async Task Undo()
    {
        if (UndoStack.Count > 0 && PixelData != null)
        {
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°é‡åšæ ˆ
            var currentState = new Color[PixelData.Length];
            Array.Copy(PixelData, currentState, PixelData.Length);
            RedoStack.Push(currentState);
            
            // ä»æ’¤é”€æ ˆä¸­å¼¹å‡ºä¸Šä¸€ä¸ªçŠ¶æ€
            PixelData = UndoStack.Pop();
            Message = "æ’¤é”€æ“ä½œæˆåŠŸ";
            Console.WriteLine("Undo operation performed");
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            await SaveCurrentState();
            
            // æ›´æ–°åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
            CalculatePixelUsageStats();
        }
        else
        {
            Message = "æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ";
            Console.WriteLine("No undo operations available");
        }
    }
    
    private async Task Redo()
    {
        if (RedoStack.Count > 0 && PixelData != null)
        {
            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°æ’¤é”€æ ˆ
            var currentState = new Color[PixelData.Length];
            Array.Copy(PixelData, currentState, PixelData.Length);
            UndoStack.Push(currentState);
            
            // ä»é‡åšæ ˆä¸­å¼¹å‡ºä¸‹ä¸€ä¸ªçŠ¶æ€
            PixelData = RedoStack.Pop();
            Message = "åæ’¤é”€æ“ä½œæˆåŠŸ";
            Console.WriteLine("Redo operation performed");
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            await SaveCurrentState();
            
            // æ›´æ–°åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
            CalculatePixelUsageStats();
        }
        else
        {
            Message = "æ²¡æœ‰å¯åæ’¤é”€çš„æ“ä½œ";
            Console.WriteLine("No redo operations available");
        }
    }
    
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // å¤„ç†Ctrl+Zæ’¤é”€æ“ä½œ
        if (e.CtrlKey && e.Key == "z")
        {
            await Undo();
        }
        // å¤„ç†Ctrl+Yåæ’¤é”€æ“ä½œ
        else if (e.CtrlKey && e.Key == "y")
        {
            await Redo();
        }
    }
    
    /// <summary>
    /// æ ¹æ®é¢œè‰²å¿«é€Ÿè·å–è‰²å·
    /// </summary>
    /// <param name="color">é¢œè‰²å€¼</param>
    /// <param name="hideTransparentCodes">æ˜¯å¦éšè—é€æ˜è‰²ä»£ç </param>
    /// <returns>é¢œè‰²å¯¹åº”çš„ä»£ç </returns>
    private string GetCodeByColorFast(Color color, bool hideTransparentCodes)
    {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦éšè—é€æ˜è‰²ä»£ç 
        if (hideTransparentCodes)
        {
            // é€æ˜åº¦ä¸º0
            if (color.A == 0)
            {
                return string.Empty;
            }
        }
        
        // ç›´æ¥ä½¿ç”¨é¢œè‰²å¯¹è±¡çš„Codeå±æ€§
        return color.Code;
    }
    
    private void ToggleSidebar()
    {
        IsSidebarCollapsed = !IsSidebarCollapsed;
    }
    
    private void SwitchTool(EditTool newTool)
    {
        // åªæœ‰å½“å½“å‰å·¥å…·ä¸æ˜¯å–è‰²å™¨æ—¶ï¼Œæ‰ä¿å­˜ä¸ºä¸Šä¸€ä¸ªå·¥å…·
        // è¿™æ ·å¯ä»¥ç¡®ä¿å–è‰²å™¨ä¸ä¼šè¦†ç›–ä¸Šä¸€ä¸ªå·¥å…·çš„è®°å½•
        if (CurrentTool != EditTool.EyeDropper)
        {
            PreviousTool = CurrentTool;
        }
        CurrentTool = newTool;
    }
    
    /// <summary>
    /// è®¡ç®—åƒç´ ä½¿ç”¨ç»Ÿè®¡æ•°æ®
    /// </summary>
    private void CalculatePixelUsageStats()
    {
        PixelUsageStats.Clear();
        
        if (PixelData != null)
        {
            foreach (var color in PixelData)
            {
                if (PixelUsageStats.ContainsKey(color))
                {
                    PixelUsageStats[color]++;
                }
                else
                {
                    PixelUsageStats[color] = 1;
                }
            }
        }
    }
    
    private async Task GoBack()
    {
        // ä¿å­˜å½“å‰çŠ¶æ€åˆ° sessionStorage
        await SaveCurrentState();
        NavigationManager.NavigateTo("/");
    }
    
    private async Task SaveCurrentStateDebounced()
    {
        // å–æ¶ˆä¹‹å‰çš„ä¿å­˜æ“ä½œ
        if (SaveDebounceToken != null)
        {
            SaveDebounceToken.Cancel();
            SaveDebounceToken.Dispose();
        }
        
        // åˆ›å»ºæ–°çš„å–æ¶ˆä»¤ç‰Œ
        SaveDebounceToken = new System.Threading.CancellationTokenSource();
        var token = SaveDebounceToken.Token;
        
        try
        {
            // å»¶è¿Ÿæ‰§è¡Œä¿å­˜æ“ä½œ
            await Task.Delay(SaveDebounceDelay, token);
            
            // æ‰§è¡Œå®é™…çš„ä¿å­˜æ“ä½œ
            if (!token.IsCancellationRequested && PixelData != null && PixelData.Length > 0)
            {
                // å°†Coloræ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ•°ç»„
                var colorStrings = PixelData.Select(c => c.ToString()).ToArray();
                var pixelDataString = string.Join(",", colorStrings);
                
                // å°†PaletteColorsè½¬æ¢ä¸ºDictionary<string, string>
                var paletteColorsStrings = new Dictionary<string, string>();
                foreach (var color in PaletteColors)
                {
                    paletteColorsStrings[color.Key] = color.Value.ToString();
                }
                
                var navigationData = new NavigationData
                {
                    Width = Width,
                    Height = Height,
                    Palette = Palette,
                    PixelData = pixelDataString,
                    CurrentPalette = paletteColorsStrings
                };
                
                var jsonData = System.Text.Json.JsonSerializer.Serialize(navigationData);
                await JSRuntime.InvokeVoidAsync("sessionStorage.setItem", "counterState", jsonData);
                Console.WriteLine("State saved to sessionStorage");
            }
        }
        catch (TaskCanceledException)
        {
            // æ“ä½œè¢«å–æ¶ˆï¼Œå¿½ç•¥
        }
        finally
        {
            // ç›´æ¥é‡Šæ”¾ä»¤ç‰Œæºï¼Œä¸éœ€è¦æ¯”è¾ƒ
            if (SaveDebounceToken != null)
            {
                SaveDebounceToken.Dispose();
                SaveDebounceToken = null;
            }
        }
    }
    
    private async Task SaveCurrentState()
    {
        // å¯¹äºç¼–è¾‘æ“ä½œï¼Œä½¿ç”¨é˜²æŠ–ä¿å­˜æ–¹æ³•
        await SaveCurrentStateDebounced();
    }
    
    private async Task ExportPixelArt()
    {
        if (PixelData != null && PixelData.Length > 0)
        {
            // Convert Color objects to string representations
            var pixelDataStrings = PixelData.Select(c => c.ToString()).ToArray();
            var paletteColorsStrings = PaletteColors.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToString());
            
            await JSRuntime.InvokeVoidAsync("exportPixelArtAsImage", Width, Height, pixelDataStrings, paletteColorsStrings, ShowCodes, HideTransparentCodes);
        }
    }
    
    private async Task SaveResource()
    {
        if (PixelData != null && PixelData.Length > 0 && PaletteColors != null && PaletteColors.Count > 0)
        {
            // åˆ›å»ºèµ„æºæ•°æ®
            var resourceData = new
            {
                Width = Width,
                Height = Height,
                Palette = PaletteColors.Select(kvp => new { Name = kvp.Key, Color = kvp.Value.ToString() }).ToList(),
                PixelData = PixelData.Select(c => c.ToString()).ToArray()
            };
            
            // åºåˆ—åŒ–ä¸º JSONï¼ˆå‹ç¼©æ ¼å¼ï¼‰
            var json = System.Text.Json.JsonSerializer.Serialize(resourceData, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = false
            });
            
            // è°ƒç”¨ JavaScript ä¿å­˜æ–‡ä»¶
            await JSRuntime.InvokeVoidAsync("saveResourceFile", json);
        }
        else
        {
            Message = "æ²¡æœ‰å¯ä¿å­˜çš„èµ„æºæ•°æ®";
        }
    }
    
    private async Task OpenResource()
    {
        // è°ƒç”¨ JavaScript æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†
        var result = await JSRuntime.InvokeAsync<string>("openResourceFile");
        
        if (!string.IsNullOrEmpty(result))
        {
            try
            {
                // ååºåˆ—åŒ–èµ„æºæ•°æ®
                var options = new System.Text.Json.JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };
                
                // ä½¿ç”¨å¼ºç±»å‹ååºåˆ—åŒ–
                var resourceData = System.Text.Json.JsonSerializer.Deserialize<ResourceData>(result, options);
                
                if (resourceData != null)
                {
                    // é‡ç½®çŠ¶æ€
                    UndoStack.Clear();
                    RedoStack.Clear();
                    
                    // æå–æ•°æ®
                    Width = resourceData.Width;
                    Height = resourceData.Height;
                    
                    // é‡å»ºè°ƒè‰²æ¿
                    PaletteColors.Clear();
                    foreach (var colorItem in resourceData.Palette)
                    {
                        var name = colorItem.Name;
                        var colorObj = Color.FromHex(colorItem.Color, name);
                        PaletteColors[name] = colorObj;
                    }
                    
                    // è§£æåƒç´ æ•°æ®
                    if (resourceData.PixelData != null)
                    {
                        var colorStrings = resourceData.PixelData;
                        PixelData = new Color[colorStrings.Length];
                        for (int i = 0; i < colorStrings.Length; i++)
                        {
                            var color = Color.FromHex(colorStrings[i]);
                            // Find the corresponding code in PaletteColors
                            foreach (var paletteColor in PaletteColors)
                            {
                                if (paletteColor.Value.Equals(color))
                                {
                                    color.Code = paletteColor.Key;
                                    break;
                                }
                            }
                            PixelData[i] = color;
                        }
                    }
                    else
                    {
                        PixelData = Array.Empty<Color>();
                    }
                    
                    // è®¾ç½®é»˜è®¤é€‰æ‹©çš„é¢œè‰²
                    if (PaletteColors.Count > 0)
                    {
                        SelectedColor = PaletteColors.First().Value;
                    }
                    
                    Message = "èµ„æºæ–‡ä»¶æ‰“å¼€æˆåŠŸ";
                    
                    // ä¿å­˜å½“å‰çŠ¶æ€ï¼ˆä½¿ç”¨ç«‹å³ä¿å­˜ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨é˜²æŠ–ï¼‰
                    await SaveCurrentStateImmediately();
                }
            }
            catch (Exception ex)
            {
                Message = $"æ‰“å¼€èµ„æºæ–‡ä»¶å¤±è´¥: {ex.Message}";
                Console.WriteLine($"Error opening resource file: {ex.Message}");
            }
        }
    }
    
    // èµ„æºæ•°æ®ç»“æ„
    private class ResourceData
    {
        public int Width { get; set; }
        public int Height { get; set; }
        public List<PaletteColor> Palette { get; set; } = new List<PaletteColor>();
        public string[] PixelData { get; set; } = Array.Empty<string>();
    }
    
    // è°ƒè‰²æ¿é¢œè‰²ç»“æ„
    private class PaletteColor
    {
        public string Name { get; set; } = string.Empty;
        public string Color { get; set; } = string.Empty;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // åˆ›å»ºDotNetObjectReferenceå¹¶ä¼ é€’ç»™JavaScript
            _dotNetReference = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setDotNetReference", _dotNetReference);
        }
        
        if (PixelData != null && PixelData.Length > 0)
        {
            // å»¶è¿Ÿè°ƒç”¨ï¼Œç¡®ä¿ DOM å…ƒç´ å·²ç»å®Œå…¨æ¸²æŸ“
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("initializeZoomAndPan");
        }
    }
    
    // å¤„ç†ç»„ä»¶é”€æ¯ï¼Œé‡Šæ”¾DotNetObjectReference
    public void Dispose()
    {
        _dotNetReference?.Dispose();
    }
    
    // ä¿å­˜å›¾ç‰‡ï¼Œç”±JavaScriptè°ƒç”¨
    [JSInvokable]
    public async Task SaveImage(byte[] imageData, string fileName)
    {
        try
        {
            bool success = await FileSaveService.SaveImageAsync(imageData, fileName);
            if (success)
            {
                Message = $"å›¾ç‰‡ä¿å­˜æˆåŠŸ: {fileName}";
            }
            else
            {
                Message = "å›¾ç‰‡ä¿å­˜å¤±è´¥";
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Message = $"ä¿å­˜å›¾ç‰‡æ—¶å‡ºé”™: {ex.Message}";
            Console.WriteLine($"Error saving image: {ex.Message}");
            StateHasChanged();
        }
    }
    
    // ä¿å­˜èµ„æºæ–‡ä»¶ï¼Œç”±JavaScriptè°ƒç”¨
    [JSInvokable]
    public async Task SaveResource(string jsonData, string fileName)
    {
        try
        {
            bool success = await FileSaveService.SaveResourceAsync(jsonData, fileName);
            if (success)
            {
                Message = $"èµ„æºä¿å­˜æˆåŠŸ: {fileName}";
            }
            else
            {
                Message = "èµ„æºä¿å­˜å¤±è´¥";
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Message = $"ä¿å­˜èµ„æºæ—¶å‡ºé”™: {ex.Message}";
            Console.WriteLine($"Error saving resource: {ex.Message}");
            StateHasChanged();
        }
    }
}
