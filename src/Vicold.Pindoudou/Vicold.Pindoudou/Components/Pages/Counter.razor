@page "/counter"
@using System.Threading.Tasks
@inject NavigationManager NavigationManager
@inject Microsoft.JSInterop.IJSRuntime JSRuntime

<h1>编辑</h1>

<div class="container">
    <div class="row">
        <!-- 左侧调色板 -->
        <div class="col-md-4">
            <h3>当前调色板</h3>
            <div class="palette-display">
                @if (PaletteColors != null && PaletteColors.Count > 0)
                {
                    <div class="compact-color-grid">
                        @foreach (var kvp in PaletteColors)
                        {
                            var color = kvp.Value;
                            var code = kvp.Key;
                            <div 
                                class="compact-color-item"
                                @onclick="() => SelectColor(color)"
                                title="点击选择颜色"
                            >
                                <div 
                                    class="color-swatch" 
                                    style="background-color: @color" 
                                ></div>
                                <div class="color-number">@(@code)</div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <p>没有可用的调色板颜色</p>
                }
            </div>
            
            <div class="mt-3">
                <h4>编辑工具</h4>
                <div class="form-group">
                    <label>当前选择的颜色:</label>
                    <div class="color-preview" style="background-color: @SelectedColor"></div>
                    <input type="color" @bind="SelectedColor" class="form-control form-control-color" />
                </div>
                
                <div class="form-group form-check">
                    <input type="checkbox" class="form-check-input" id="showCodes" @bind="ShowCodes" />
                    <label class="form-check-label" for="showCodes">显示代码</label>
                </div>
                
                <div class="form-group form-check">
                    <input type="checkbox" class="form-check-input" id="hideTransparentCodes" @bind="HideTransparentCodes" />
                    <label class="form-check-label" for="hideTransparentCodes">隐藏透明色代码</label>
                </div>
                
                <button class="btn btn-primary mt-2 mr-2" @onclick="ExportPixelArt">导出图片</button>
                <button class="btn btn-secondary mt-2" @onclick="GoBack">返回</button>
            </div>
        </div>
        
        <!-- 右侧像素图编辑区域 -->
        <div class="col-md-8">
            <h3>像素图编辑</h3>
            <div class="edit-container">
                @if (PixelData != null && PixelData.Length > 0)
                {
                    <div class="zoomable-container" id="zoomableContainer">
                        <div class="zoomable-content" id="zoomableContent" style="transform-origin: 0 0;">
                            <div class="pixel-art">
                                @for (int y = 0; y < Height; y++)
                                {
                                    <div class="pixel-row">
                                        @for (int x = 0; x < Width; x++)
                                        {
                                            var index = y * Width + x;
                                            if (index < PixelData.Length)
                                            {
                                                <div 
                                                    class="pixel" 
                                                    style="background-color: @PixelData[index]"
                                                    @onclick="() => EditPixel(x, y)"
                                                    title="@PixelData[index]" >
                                                    @if (ShowCodes)
                                                    {
                                                        var code = GetCodeByColor(PixelData[index]);
                                                        if (!string.IsNullOrEmpty(code))
                                                        {
                                                            var textColor = GetContrastTextColor(PixelData[index]);
                                                            <div class="color-number-in-pixel" style="color: @textColor">
                                                                @(code)
                                                            </div>
                                                        }
                                                    }
                                                </div>
                                            }
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <p>没有可编辑的像素图</p>
                }
            </div>
        </div>
    </div>
</div>

<style>
    .edit-container {
        border: 1px solid #ddd;
        padding: 20px;
        min-height: 800px;
        text-align: center;
        background-color: #f9f9f9;
        overflow: hidden;
        position: relative;
    }
    
    .zoomable-container {
        width: 100%;
        height: 760px;
        overflow: hidden;
        position: relative;
        background-color: #fff;
        border: 1px solid #eee;
        cursor: grab;
    }
    
    .zoomable-container:active {
        cursor: grabbing;
    }
    
    .zoomable-content {
        position: absolute;
        top: 0;
        left: 0;
        transform: scale(1);
        transition: transform 0.1s ease;
    }
    
    .pixel-art {
        margin: 0;
    }
    
    .pixel-row {
        display: flex;
    }
    
    .pixel {
        width: 20px;
        height: 20px;
        border: 1px solid #eee;
        cursor: pointer;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }
    
    .pixel:hover {
        border: 1px solid #000;
    }
    
    .palette-display {
        border: 1px solid #ddd;
        padding: 10px;
        background-color: #f9f9f9;
    }
    
    .compact-color-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
    }
    
    .compact-color-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1px;
        cursor: pointer;
        width: 40px;
        margin-bottom: 5px;
    }
    
    .color-swatch {
        width: 30px;
        height: 30px;
        border: 1px solid #ddd;
    }
    
    .compact-color-item:hover .color-swatch {
        border: 1px solid #000;
    }

    .color-number {
        font-size: 10px;
        color: #333;
        text-align: center;
        width: 100%;
    }

    .color-number-in-pixel {
        font-size: 8px;
        color: #333;
        text-align: center;
        width: 100%;
        font-weight: bold;
        line-height: 1;
        margin: 0;
        padding: 0;
    }
    
    .color-preview {
        width: 60px;
        height: 40px;
        border: 1px solid #ddd;
        margin-bottom: 10px;
    }
    
    .form-control-color {
        width: 60px;
        height: 40px;
        padding: 0;
    }
</style>

@code {
    private string[]? PixelData { get; set; }
    private int Width { get; set; }
    private int Height { get; set; }
    private string Palette { get; set; } = "Mard";
    private Dictionary<string, string> PaletteColors { get; set; } = new Dictionary<string, string>();
    private string SelectedColor { get; set; } = "#FFFFFF";
    private bool ShowCodes { get; set; } = true;
    private bool HideTransparentCodes { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        // 从 sessionStorage 中获取数据
        var jsonData = await JSRuntime.InvokeAsync<string>("sessionStorage.getItem", "navigationData");
        
        if (!string.IsNullOrEmpty(jsonData))
        {
            try
            {
                // 使用具体的类型而不是dynamic
                var options = new System.Text.Json.JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };
                
                var navigationData = System.Text.Json.JsonSerializer.Deserialize<NavigationData>(jsonData, options);
                
                if (navigationData != null)
                {
                    // 解析参数
                    Width = navigationData.Width;
                    Height = navigationData.Height;
                    Palette = navigationData.Palette;
                    
                    // 解析像素数据
                    var pixelDataString = navigationData.PixelData;
                    if (!string.IsNullOrEmpty(pixelDataString))
                    {
                        PixelData = pixelDataString.Split(',');
                    }
                    
                    // 解析调色板颜色
                    var paletteColorsString = navigationData.CurrentPalette;
                    foreach (var color in paletteColorsString)
                    {
                        PaletteColors[color.Key] = color.Value; // code为key，color为value
                    }
                    
                    // 设置默认选择的颜色
                    if (PaletteColors.Count > 0)
                    {
                        SelectedColor = PaletteColors.First().Value;
                    }
                }
                
                // 清除 sessionStorage 中的数据
                await JSRuntime.InvokeVoidAsync("sessionStorage.removeItem", "navigationData");
            }
            catch (Exception ex)
            {
                // 错误处理
                Console.WriteLine($"Error parsing navigation data: {ex.Message}");
                // 如果解析失败，使用默认值
                Width = 20;
                Height = 20;
                Palette = "Mard";
                PaletteColors = new Dictionary<string, string>();
                SelectedColor = "#FFFFFF";
            }
        }
        else
        {
            // 如果没有数据，使用默认值
            Width = 20;
            Height = 20;
            Palette = "Mard";
            PaletteColors = new Dictionary<string, string>();
            SelectedColor = "#FFFFFF";
        }
    }
    
    // 导航数据模型
    private class NavigationData
    {
        public int Width { get; set; }
        public int Height { get; set; }
        public string Palette { get; set; }
        public string PixelData { get; set; }
        public string PaletteColors { get; set; }
        public Dictionary<string, string> CurrentPalette { get; set; }
    }
    
    // 根据颜色值获取对应的代码
    private string GetCodeByColor(string color)
    {
        // 检查是否需要隐藏透明色代码
        if (HideTransparentCodes)
        {
            // #RRGGBBAA 格式，最后两位为00
            if (color.Length == 9 && color.EndsWith("00", StringComparison.OrdinalIgnoreCase))
            {
                return string.Empty;
            }
        }
        
        foreach (var kvp in PaletteColors)
        {
            if (kvp.Value == color)
            {
                return kvp.Key;
            }
        }
        return string.Empty;
    }
    
    // 计算颜色的亮度
    private double CalculateColorLuminance(string color)
    {
        // 解析颜色值
        int r, g, b;
        
        if (color.StartsWith("#"))
        {
            color = color.Substring(1);
        }
        
        if (color.Length == 6)
        {
            // #RRGGBB 格式
            r = Convert.ToInt32(color.Substring(0, 2), 16);
            g = Convert.ToInt32(color.Substring(2, 2), 16);
            b = Convert.ToInt32(color.Substring(4, 2), 16);
        }
        else if (color.Length == 8)
        {
            r = Convert.ToInt32(color.Substring(0, 2), 16);
            g = Convert.ToInt32(color.Substring(2, 2), 16);
            b = Convert.ToInt32(color.Substring(4, 2), 16);
        }
        else if (color.Length == 3)
        {
            // #RGB 格式
            r = Convert.ToInt32(color.Substring(0, 1) + color.Substring(0, 1), 16);
            g = Convert.ToInt32(color.Substring(1, 1) + color.Substring(1, 1), 16);
            b = Convert.ToInt32(color.Substring(2, 1) + color.Substring(2, 1), 16);
        }
        else
        {
            // 默认黑色
            return 0;
        }
        
        // 计算亮度（使用相对亮度公式）
        return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    }
    
    // 根据背景颜色获取对比度高的文本颜色（黑色或白色）
    private string GetContrastTextColor(string color)
    {
        // 计算亮度
        double luminance = CalculateColorLuminance(color);
        
        // 如果亮度大于0.5，使用黑色文本；否则使用白色文本
        return luminance > 0.5 ? "#000000" : "#FFFFFF";
    }
    
    // 判断颜色是否为浅色
    private bool IsLightColor(string color)
    {
        // 计算亮度
        double luminance = CalculateColorLuminance(color);
        
        // 亮度大于0.5视为浅色
        return luminance > 0.5;
    }
    
    private int GetQueryParameter(string queryString, string parameterName, int defaultValue)
    {
        var parameter = GetQueryParameter(queryString, parameterName, string.Empty);
        if (int.TryParse(parameter, out var value))
        {
            return value;
        }
        return defaultValue;
    }
    
    private string GetQueryParameter(string queryString, string parameterName, string defaultValue)
    {
        if (string.IsNullOrEmpty(queryString))
        {
            return defaultValue;
        }
        
        // 移除开头的 ?
        if (queryString.StartsWith("?"))
        {
            queryString = queryString.Substring(1);
        }
        
        // 分割参数
        var parameters = queryString.Split('&');
        foreach (var param in parameters)
        {
            var parts = param.Split('=');
            if (parts.Length == 2 && parts[0] == parameterName)
            {
                return Uri.UnescapeDataString(parts[1]);
            }
        }
        
        return defaultValue;
    }
    
    private void EditPixel(int x, int y)
    {
        var index = y * Width + x;
        if (index >= 0 && index < PixelData?.Length)
        {
            PixelData[index] = SelectedColor;
        }
    }
    
    private void SelectColor(string color)
    {
        SelectedColor = color;
    }
    
    private void GoBack()
    {
        NavigationManager.NavigateTo("/");
    }
    
    private async Task ExportPixelArt()
    {
        if (PixelData != null && PixelData.Length > 0)
        {
            await JSRuntime.InvokeVoidAsync("exportPixelArtAsImage", Width, Height, PixelData, PaletteColors, ShowCodes, HideTransparentCodes);
        }
    }
    
    private string GetPaletteCode(int index)
    {
        // 生成类似 A1、A2、B1、B2 的调色板代码
        char letter = (char)('A' + (index / 10));
        int number = (index % 10) + 1;
        return $"{letter}{number}";
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (PixelData != null && PixelData.Length > 0)
        {
            // 延迟调用，确保 DOM 元素已经完全渲染
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("initializeZoomAndPan");
        }
    }
}



<script>
    // 计算颜色的亮度
    function calculateColorLuminance(color) {
        // 解析颜色值
        let r, g, b;
        
        if (color.startsWith('#')) {
            color = color.substring(1);
        }
        
        if (color.length === 6) {
            // #RRGGBB 格式
            r = parseInt(color.substring(0, 2), 16);
            g = parseInt(color.substring(2, 4), 16);
            b = parseInt(color.substring(4, 6), 16);
        } else if (color.length === 8) {
            // #AARRGGBB 或 #RRGGBBAA 格式
            if (color.toLowerCase().endsWith('00')) {
                // #RRGGBBAA 格式
                r = parseInt(color.substring(0, 2), 16);
                g = parseInt(color.substring(2, 4), 16);
                b = parseInt(color.substring(4, 6), 16);
            } else {
                // #AARRGGBB 格式
                r = parseInt(color.substring(2, 4), 16);
                g = parseInt(color.substring(4, 6), 16);
                b = parseInt(color.substring(6, 8), 16);
            }
        } else if (color.length === 3) {
            // #RGB 格式
            r = parseInt(color.substring(0, 1) + color.substring(0, 1), 16);
            g = parseInt(color.substring(1, 2) + color.substring(1, 2), 16);
            b = parseInt(color.substring(2, 3) + color.substring(2, 3), 16);
        } else {
            // 默认黑色
            return 0;
        }
        
        // 计算亮度（使用相对亮度公式）
        return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    }
    
    // 判断颜色是否为浅色
    function isLightColor(color) {
        // 计算亮度
        const luminance = calculateColorLuminance(color);
        
        // 亮度大于0.5视为浅色
        return luminance > 0.5;
    }
    
    // 根据背景颜色获取对比度高的文本颜色（黑色或白色）
    function getContrastTextColor(color) {
        // 计算亮度
        const luminance = calculateColorLuminance(color);
        
        // 如果亮度大于0.5，使用黑色文本；否则使用白色文本
        return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }
    
    // 全局变量，用于保存缩放状态
    window.zoomState = {
        scale: 1,
        translateX: 0,
        translateY: 0
    };
    
    // 根据背景颜色获取对比度高的文本颜色（黑色或白色）
    function getContrastTextColor(color) {
        // 解析颜色值
        let r, g, b;
        
        if (color.startsWith('#')) {
            color = color.substring(1);
        }
        
        if (color.length === 6) {
            // #RRGGBB 格式
            r = parseInt(color.substring(0, 2), 16);
            g = parseInt(color.substring(2, 4), 16);
            b = parseInt(color.substring(4, 6), 16);
        }
        else if (color.length === 9) {
            // #AARRGGBB 或 #RRGGBBAA 格式
            if (color.endsWith('00')) {
                // #RRGGBBAA 格式
                r = parseInt(color.substring(0, 2), 16);
                g = parseInt(color.substring(2, 4), 16);
                b = parseInt(color.substring(4, 6), 16);
            }
            else {
                // #AARRGGBB 格式
                r = parseInt(color.substring(2, 4), 16);
                g = parseInt(color.substring(4, 6), 16);
                b = parseInt(color.substring(6, 8), 16);
            }
        }
        else {
            // 默认黑色
            return '#000000';
        }
        
        // 计算亮度（使用相对亮度公式）
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        
        // 如果亮度大于0.5，使用黑色文本；否则使用白色文本
        return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }
    
    // 全局函数，供 Blazor 调用
    window.initializeZoomAndPan = function() {
        // 尝试获取元素
        const container = document.getElementById('zoomableContainer');
        const content = document.getElementById('zoomableContent');
        
        if (!container || !content) {
            return;
        }
        
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        
        // 从全局变量恢复缩放状态
        let scale = window.zoomState.scale;
        let translateX = window.zoomState.translateX;
        let translateY = window.zoomState.translateY;
        
        // 初始化位置，使内容居中（仅在首次加载时）
        const centerContent = () => {
            const containerRect = container.getBoundingClientRect();
            const contentRect = content.getBoundingClientRect();
            
            translateX = (containerRect.width - contentRect.width * scale) / 2;
            translateY = (containerRect.height - contentRect.height * scale) / 2;
            
            // 保存初始状态
            window.zoomState.scale = scale;
            window.zoomState.translateX = translateX;
            window.zoomState.translateY = translateY;
            
            updateTransform();
        };
        
        // 更新变换
        const updateTransform = () => {
            const transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            content.style.transform = transform;
            
            // 保存状态
            window.zoomState.scale = scale;
            window.zoomState.translateX = translateX;
            window.zoomState.translateY = translateY;
        };
        
        // 鼠标按下事件
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            container.style.userSelect = 'none';
        });
        
        // 鼠标移动事件
        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateTransform();
        });
        
        // 鼠标释放事件
        container.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.userSelect = 'auto';
        });
        
        // 鼠标离开事件
        container.addEventListener('mouseleave', () => {
            isDragging = false;
            container.style.userSelect = 'auto';
        });
        
        // 滚轮缩放事件
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // 计算缩放因子
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, scale * scaleFactor));
            
            // 计算鼠标在容器中的位置
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 计算缩放前后鼠标在内容上的位置
            const relativeX = (mouseX - translateX) / scale;
            const relativeY = (mouseY - translateY) / scale;
            
            // 计算新的偏移量，使鼠标位置保持不变
            scale = newScale;
            translateX = mouseX - relativeX * scale;
            translateY = mouseY - relativeY * scale;
            
            updateTransform();
        });
        
        // 检查是否是首次加载（缩放状态为默认值）
        if (window.zoomState.scale === 1 && window.zoomState.translateX === 0 && window.zoomState.translateY === 0) {
            // 首次加载，居中显示
            centerContent();
        } else {
            // 非首次加载，恢复之前的状态
            updateTransform();
        }
    };
    
    // 导出像素图为图片
    window.exportPixelArtAsImage = function(width, height, pixelData, paletteColors, showCodes, hideTransparentCodes) {
        // 配置参数
        const pixelSize = 40; // 每个像素的大小，增大一倍以提高清晰度
        const padding = 70; // 留白大小
        const codeFontSize = 16; // 像素中代码字号
        const paletteTitleFontSize = 40; // 调色板标题字号
        const paletteCodeFontSize = 16; // 调色板项中代码字号
        const paletteCountFontSize = 16; // 调色板项中数量字号
        const paletteItemSize = 40; // 调色板项大小
        const gridNumberFontSize = 16; // 网格编号字号
        
        // 统计每个颜色的使用数量
        const colorCount = {};
        for (let i = 0; i < pixelData.length; i++) {
            const color = pixelData[i];
            
            // 检查是否需要跳过透明色
            let shouldCountColor = true;
            if (hideTransparentCodes) {
                // 判断是否为透明色
                // 情况1：#RRGGBBAA 格式，最后两位为00
                if (color.length === 9 && color.endsWith('00')) {
                    shouldCountColor = false;
                }
                // 情况2：#AARRGGBB 格式，前两位为00
                else if (color.length === 9 && color.substring(1, 3) === '00') {
                    shouldCountColor = false;
                }
                // 情况3：8位格式，如FFFFFF00（白色透明）
                else if (color === 'FFFFFF00') {
                    shouldCountColor = false;
                }
            }
            
            if (shouldCountColor) {
                if (colorCount[color]) {
                    colorCount[color]++;
                } else {
                    colorCount[color] = 1;
                }
            }
        }
        
        // 计算Canvas尺寸
        const canvasWidth = width * pixelSize + padding * 2;
        const paletteColorsArray = Object.entries(paletteColors);
        const maxPerRow = Math.floor((canvasWidth - padding * 2) / (paletteItemSize + 10));
        const paletteHeight = Math.ceil(paletteColorsArray.length / maxPerRow) * (paletteItemSize + 25) + padding * 2;
        const canvasHeight = height * pixelSize + padding * 2 + paletteHeight;
        
        // 创建Canvas元素
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        
        // 填充背景
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // 绘制像素
        const pixelStartX = padding;
        const pixelStartY = padding;
        
        // 绘制网格编号
        ctx.fillStyle = '#333';
        ctx.font = gridNumberFontSize + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 绘制顶部编号（X轴，从左到右）
        for (let x = 0; x < width; x++) {
            const nx = pixelStartX + x * pixelSize + pixelSize / 2;
            const ny = pixelStartY - 15;
            ctx.fillText((x+1).toString(), nx, ny);
        }
        
        // 绘制底部编号（X轴，从左到右）
        for (let x = 0; x < width; x++) {
            const nx = pixelStartX + x * pixelSize + pixelSize / 2;
            const ny = pixelStartY + height * pixelSize + 15;
            ctx.fillText((x+1).toString(), nx, ny);
        }
        
        // 绘制左侧编号（Y轴，从下到上，左下角为0）
        for (let y = 0; y < height; y++) {
            const nx = pixelStartX - 15;
            const ny = pixelStartY + (height - 1 - y) * pixelSize + pixelSize / 2;
            ctx.fillText((y+1).toString(), nx, ny);
        }
        
        // 绘制右侧编号（Y轴，从下到上，左下角为0）
        for (let y = 0; y < height; y++) {
            const nx = pixelStartX + width * pixelSize + 15;
            const ny = pixelStartY + (height - 1 - y) * pixelSize + pixelSize / 2;
            ctx.fillText((y+1).toString(), nx, ny);
        }
        
        // 绘制像素
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = y * width + x;
                const color = pixelData[index];
                const px = pixelStartX + x * pixelSize;
                const py = pixelStartY + y * pixelSize;
                
                // 绘制像素背景
                ctx.fillStyle = color;
                ctx.fillRect(px, py, pixelSize, pixelSize);
                
                // 绘制像素边框
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, pixelSize, pixelSize);
                
                // 如果需要显示代码
                if (showCodes) {
                    // 检查是否需要隐藏透明色代码
                    let shouldShowCode = true;
                    if (hideTransparentCodes) {
                        // 判断是否为透明色
                        // 情况1：#RRGGBBAA 格式，最后两位为00
                        if (color.length === 9 && color.endsWith('00')) {
                            shouldShowCode = false;
                        }
                        // 情况2：#AARRGGBB 格式，前两位为00
                        else if (color.length === 9 && color.substring(1, 3) === '00') {
                            shouldShowCode = false;
                        }
                        // 情况3：8位格式，如FFFFFF00（白色透明）
                        else if (color === 'FFFFFF00') {
                            shouldShowCode = false;
                        }
                    }
                    
                    if (shouldShowCode) {
                        // 查找对应的代码
                        let code = '';
                        for (const [codeValue,colorKey] of Object.entries(paletteColors)) {
                            if (colorKey === color) {
                                code = codeValue;
                                break;
                            }
                        }
                        
                        // 绘制代码
                        if (code) {
                            // 根据背景颜色计算文本颜色
                            const textColor = getContrastTextColor(color);
                            ctx.fillStyle = textColor;
                            ctx.font = codeFontSize + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(code, px + pixelSize / 2, py + pixelSize / 2);
                        }
                    }
                }
            }
        }
        
        // 绘制调色板示例
        const paletteStartY = pixelStartY + height * pixelSize + padding;
        const paletteStartX = padding;
        
        // 绘制调色板标题
        ctx.fillStyle = '#333';
        ctx.font = paletteTitleFontSize + 'px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('调色板', canvasWidth / 2, paletteStartY + 20);
        
        // 绘制调色板项
        let paletteX = paletteStartX;
        let paletteY = paletteStartY + 40;
        let count = 0;
        
        for (const [code, color] of paletteColorsArray) {
            // 计算每个调色板项的宽度，使它们从左到右占满
            const colorCountValue = colorCount[color] || 0;
            if (colorCountValue == 0) {
                continue;    
            }
            const itemWidth = (canvasWidth - padding * 2 - (maxPerRow - 1) * 10) / maxPerRow;
            
            // 绘制色块
            ctx.fillStyle = color;
            ctx.fillRect(paletteX, paletteY, itemWidth, paletteItemSize);
            
            // 绘制色块边框
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            ctx.strokeRect(paletteX, paletteY, itemWidth, paletteItemSize);
            
            // 绘制代码（放到色块内部）
            // 根据背景颜色的明暗程度自动调整文字颜色
            ctx.fillStyle = isLightColor(color) ? '#333' : '#fff';
            ctx.font = paletteCodeFontSize + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(code, paletteX + itemWidth / 2, paletteY + paletteItemSize / 2);
            
            // 绘制数量
            ctx.fillStyle = '#666';
            ctx.font = paletteCountFontSize + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(colorCountValue, paletteX + itemWidth / 2, paletteY + paletteItemSize + 4);
            
            // 更新位置
            count++;
            if (count % maxPerRow === 0) {
                paletteX = paletteStartX;
                paletteY += paletteItemSize + 40;
            } else {
                paletteX += itemWidth + 10;
            }
        }
        
        // 转换为图片并下载
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'pixel-art.png';
        link.href = dataURL;
        link.click();
    };
</script>
