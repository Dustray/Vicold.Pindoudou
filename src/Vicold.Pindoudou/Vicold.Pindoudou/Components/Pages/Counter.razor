@page "/counter"
@using System.Threading.Tasks
@inject NavigationManager NavigationManager
@inject Microsoft.JSInterop.IJSRuntime JSRuntime

<h1>编辑</h1>

<div class="container">
    <div class="row">
        <!-- 左侧调色板 -->
        <div class="col-md-4">
            <h3>当前调色板</h3>
            <div class="palette-display">
                @if (PaletteColors != null && PaletteColors.Count > 0)
                {
                    <div class="compact-color-grid">
                        @for (int i = 0; i < PaletteColors.Count; i++)
                        {
                            var index = i;
                            <div 
                                class="compact-color-item"
                                @onclick="() => SelectColor(PaletteColors[index])"
                                title="点击选择颜色"
                            >
                                <div 
                                    class="color-swatch" 
                                    style="background-color: @PaletteColors[index]" 
                                ></div>
                                <div class="color-number">@GetPaletteCode(index)</div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <p>没有可用的调色板颜色</p>
                }
            </div>
            
            <div class="mt-3">
                <h4>编辑工具</h4>
                <div class="form-group">
                    <label>当前选择的颜色:</label>
                    <div class="color-preview" style="background-color: @SelectedColor"></div>
                    <input type="color" @bind="SelectedColor" class="form-control form-control-color" />
                </div>
                
                <button class="btn btn-secondary mt-2" @onclick="GoBack">返回</button>
            </div>
        </div>
        
        <!-- 右侧像素图编辑区域 -->
        <div class="col-md-8">
            <h3>像素图编辑</h3>
            <div class="edit-container">
                @if (PixelData != null && PixelData.Length > 0)
                {
                    <div class="zoomable-container" id="zoomableContainer">
                        <div class="zoomable-content" id="zoomableContent" style="transform-origin: 0 0;">
                            <div class="pixel-art">
                                @for (int y = 0; y < Height; y++)
                                {
                                    <div class="pixel-row">
                                        @for (int x = 0; x < Width; x++)
                                        {
                                            var index = y * Width + x;
                                            if (index < PixelData.Length)
                                            {
                                                <div 
                                                    class="pixel" 
                                                    style="background-color: @PixelData[index]"
                                                    @onclick="() => EditPixel(x, y)"
                                                    title="点击编辑像素"
                                                ></div>
                                            }
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <p>没有可编辑的像素图</p>
                }
            </div>
        </div>
    </div>
</div>

<style>
    .edit-container {
        border: 1px solid #ddd;
        padding: 20px;
        min-height: 800px;
        text-align: center;
        background-color: #f9f9f9;
        overflow: hidden;
        position: relative;
    }
    
    .zoomable-container {
        width: 100%;
        height: 760px;
        overflow: hidden;
        position: relative;
        background-color: #fff;
        border: 1px solid #eee;
        cursor: grab;
    }
    
    .zoomable-container:active {
        cursor: grabbing;
    }
    
    .zoomable-content {
        position: absolute;
        top: 0;
        left: 0;
        transform: scale(1);
        transition: transform 0.1s ease;
    }
    
    .pixel-art {
        margin: 0;
    }
    
    .pixel-row {
        display: flex;
    }
    
    .pixel {
        width: 20px;
        height: 20px;
        border: 1px solid #eee;
        cursor: pointer;
        box-sizing: border-box;
    }
    
    .pixel:hover {
        border: 1px solid #000;
    }
    
    .palette-display {
        border: 1px solid #ddd;
        padding: 10px;
        background-color: #f9f9f9;
    }
    
    .compact-color-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
    }
    
    .compact-color-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1px;
        cursor: pointer;
        width: 40px;
        margin-bottom: 5px;
    }
    
    .color-swatch {
        width: 30px;
        height: 30px;
        border: 1px solid #ddd;
    }
    
    .compact-color-item:hover .color-swatch {
        border: 1px solid #000;
    }
    
    .color-number {
        font-size: 8px;
        color: #333;
        text-align: center;
        width: 100%;
    }
    
    .color-preview {
        width: 60px;
        height: 40px;
        border: 1px solid #ddd;
        margin-bottom: 10px;
    }
    
    .form-control-color {
        width: 60px;
        height: 40px;
        padding: 0;
    }
</style>

@code {
    private string[]? PixelData { get; set; }
    private int Width { get; set; }
    private int Height { get; set; }
    private string Palette { get; set; } = "Mard";
    private List<string> PaletteColors { get; set; } = new List<string>();
    private string SelectedColor { get; set; } = "#FFFFFF";
    
    protected override void OnInitialized()
    {
        // 从 URL 参数中获取数据
        var uri = new Uri(NavigationManager.Uri);
        var queryString = uri.Query;
        
        // 解析参数
        Width = GetQueryParameter(queryString, "width", 20);
        Height = GetQueryParameter(queryString, "height", 20);
        Palette = GetQueryParameter(queryString, "palette", "Mard");
        
        // 解析像素数据
        var pixelDataString = GetQueryParameter(queryString, "pixelData", "");
        if (!string.IsNullOrEmpty(pixelDataString))
        {
            PixelData = pixelDataString.Split(',');
        }
        
        // 解析调色板颜色
        var paletteColorsString = GetQueryParameter(queryString, "paletteColors", "");
        if (!string.IsNullOrEmpty(paletteColorsString))
        {
            PaletteColors = paletteColorsString.Split(',').ToList();
        }
        
        // 设置默认选择的颜色
        if (PaletteColors.Count > 0)
        {
            SelectedColor = PaletteColors[0];
        }
    }
    
    private int GetQueryParameter(string queryString, string parameterName, int defaultValue)
    {
        var parameter = GetQueryParameter(queryString, parameterName, string.Empty);
        if (int.TryParse(parameter, out var value))
        {
            return value;
        }
        return defaultValue;
    }
    
    private string GetQueryParameter(string queryString, string parameterName, string defaultValue)
    {
        if (string.IsNullOrEmpty(queryString))
        {
            return defaultValue;
        }
        
        // 移除开头的 ?
        if (queryString.StartsWith("?"))
        {
            queryString = queryString.Substring(1);
        }
        
        // 分割参数
        var parameters = queryString.Split('&');
        foreach (var param in parameters)
        {
            var parts = param.Split('=');
            if (parts.Length == 2 && parts[0] == parameterName)
            {
                return Uri.UnescapeDataString(parts[1]);
            }
        }
        
        return defaultValue;
    }
    
    private void EditPixel(int x, int y)
    {
        var index = y * Width + x;
        if (index >= 0 && index < PixelData?.Length)
        {
            PixelData[index] = SelectedColor;
        }
    }
    
    private void SelectColor(string color)
    {
        SelectedColor = color;
    }
    
    private void GoBack()
    {
        NavigationManager.NavigateTo("/");
    }
    
    private string GetPaletteCode(int index)
    {
        // 生成类似 A1、A2、B1、B2 的调色板代码
        char letter = (char)('A' + (index / 10));
        int number = (index % 10) + 1;
        return $"{letter}{number}";
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (PixelData != null && PixelData.Length > 0)
        {
            // 延迟调用，确保 DOM 元素已经完全渲染
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("initializeZoomAndPan");
        }
    }
}

<script>
    // 全局变量，用于保存缩放状态
    window.zoomState = {
        scale: 1,
        translateX: 0,
        translateY: 0
    };
    
    // 全局函数，供 Blazor 调用
    window.initializeZoomAndPan = function() {
        // 尝试获取元素
        const container = document.getElementById('zoomableContainer');
        const content = document.getElementById('zoomableContent');
        
        if (!container || !content) {
            return;
        }
        
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        
        // 从全局变量恢复缩放状态
        let scale = window.zoomState.scale;
        let translateX = window.zoomState.translateX;
        let translateY = window.zoomState.translateY;
        
        // 初始化位置，使内容居中（仅在首次加载时）
        const centerContent = () => {
            const containerRect = container.getBoundingClientRect();
            const contentRect = content.getBoundingClientRect();
            
            translateX = (containerRect.width - contentRect.width * scale) / 2;
            translateY = (containerRect.height - contentRect.height * scale) / 2;
            
            // 保存初始状态
            window.zoomState.scale = scale;
            window.zoomState.translateX = translateX;
            window.zoomState.translateY = translateY;
            
            updateTransform();
        };
        
        // 更新变换
        const updateTransform = () => {
            const transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            content.style.transform = transform;
            
            // 保存状态
            window.zoomState.scale = scale;
            window.zoomState.translateX = translateX;
            window.zoomState.translateY = translateY;
        };
        
        // 鼠标按下事件
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            container.style.userSelect = 'none';
        });
        
        // 鼠标移动事件
        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateTransform();
        });
        
        // 鼠标释放事件
        container.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.userSelect = 'auto';
        });
        
        // 鼠标离开事件
        container.addEventListener('mouseleave', () => {
            isDragging = false;
            container.style.userSelect = 'auto';
        });
        
        // 滚轮缩放事件
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // 计算缩放因子
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, scale * scaleFactor));
            
            // 计算鼠标在容器中的位置
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 计算缩放前后鼠标在内容上的位置
            const relativeX = (mouseX - translateX) / scale;
            const relativeY = (mouseY - translateY) / scale;
            
            // 计算新的偏移量，使鼠标位置保持不变
            scale = newScale;
            translateX = mouseX - relativeX * scale;
            translateY = mouseY - relativeY * scale;
            
            updateTransform();
        });
        
        // 检查是否是首次加载（缩放状态为默认值）
        if (window.zoomState.scale === 1 && window.zoomState.translateX === 0 && window.zoomState.translateY === 0) {
            // 首次加载，居中显示
            centerContent();
        } else {
            // 非首次加载，恢复之前的状态
            updateTransform();
        }
    };
</script>
